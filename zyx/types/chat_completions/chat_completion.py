"""
zyx.types.chat_completions.chat_completion

This module provides a `ChatCompletion` class that extends the `openai.types.chat.chat_completion.ChatCompletion` class.
"""

from __future__ import annotations

from typing import Any, Generic, TypeVar, Union
from pydantic import BaseModel
import json
from openai.types.chat.chat_completion import ChatCompletion as _ChatCompletion

from zyx import logging


# [Types]
T = TypeVar("T", bound=BaseModel)


# [Generic Completion Type (for generic typing of response_format)]
GenericCompletion = Union[str, int, float, bool, list, dict, list[str], list[int], list[float], list[bool]]


# Output Object
class ChatCompletion(_ChatCompletion, Generic[T]):
    """
    `ChatCompletion` extension generated by `zyx`.

    This class tries to build upon the 'ease of use' of the `Instructor` library when
    generating structured outputs, as well as adding some extended outputs that are `zyx`
    specific.
    """

    # == .pydantic ==
    # Initialized pydantic basemodel for structured outputs if `response_format` is provided
    # The hope was to use the `model` attribute, but that is ChatCompletion API spec standard for model name
    pydantic: T | None = None
    """
    Pydantic model for structured outputs if `response_format` is provided
    """

    def __init__(self, response: Any, response_format: type[T] | None = None, **kwargs):
        """Initialize the CompletionResponse with any additional fields."""
        # Initialize parent class with standard fields
        super().__init__(**(response.model_dump() if isinstance(response, BaseModel) else response), **kwargs)

        # Initialize pydantic attribute if response_format is provided
        if response_format is not None:
            if not "choices" in response:
                raise logging.ZyxException(f"No 'choices' found in response, is this a Chat Completion?: {response}")

            if isinstance(response, BaseModel):
                content = response.choices[0].message.content
            else:
                content = response["choices"][0]["message"]["content"]

            try:
                # Parse the JSON content directly and set as pydantic attribute
                parsed_content = json.loads(content)
                # Ensure response_format is a Pydantic model
                if issubclass(response_format, BaseModel):
                    self.pydantic = response_format(**parsed_content)
            except Exception as e:
                raise logging.ZyxException(f"Error initializing response format: {e}")

        # Allow any additional fields to be set
        for key, value in kwargs.items():
            setattr(self, key, value)

        logging.debug(f"parsed response successfully, initialized with: {self}")
