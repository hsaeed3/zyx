{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"zyx","text":"<p>zyx 0.3.00 - the first 'release' of the library is out!  All CrewAI &amp; other obstructions have been removed, and the library is back to being lightweight.</p> <p><code>zyx</code> is a hyper-fast, fun, &amp; ease-of-use focused Python library for using LLMs.  It was created on top of <code>Instructor</code> and <code>LiteLLM</code>, and focuses to provide an abstraction free framework.  The library uses methods such as lazy-loading to provide a single import for all its features. This library is not meant to be used as a production-ready solution, but rather as a tool to quickly &amp; easily experiment with LLMs. </p> <p>Some of the key features of <code>zyx</code> include:</p> <ul> <li>Universal Completion Client : A singular function that handles all LiteLLM compatible models, Pydantic structured outputs, tool calling &amp; execution, prompt optimization, streaming &amp; vision support.</li> <li>A Large Collection of LLM Powered Functions : This library is inspired by <code>MarvinAI</code>, and it's quick LLM function style framework and has built upon it vastly.</li> <li>Easy to Use Memory (Rag) : A <code>Qdrant</code> wrapper, built to support easy store creation, text/document/pydantic model data insertion, universal embedding provider support, LLM completions for RAG &amp; more.</li> <li>Multimodel Generations : Supports generations for images, audio &amp; speech transcription.</li> <li>Functional / Easy Access Terminal Client : A terminal client built using <code>textual</code> to allow for easy access to <code>zyx</code> features.</li> <li>New Experimental Conversational Multi-Agent Framework : Built from the ground up using <code>Instructor</code>, the agentic framework provides a solution towards conversationally state managed agents, with task creation, custom tool use, artifact creation &amp; more.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install zyx\n</code></pre>"},{"location":"examples/getting-started/","title":"Getting Started","text":"<p>Install the package with pip:</p> <pre><code>pip install zyx\n</code></pre>"},{"location":"examples/llm/code/","title":"Generative Code Functions","text":"<p><code>zyx</code> comes with a set of functions to help you generate and execute code, making it easier to get things done in a weirder way. This builds off of the concept provided by Marvin's <code>.fn()</code> function.</p>"},{"location":"examples/llm/code/#function","title":".function()","text":"<p>Create a generative function</p> <pre><code>from zyx import function\n\n# .function() is a decorator, that generates your defined functions\n@function()\ndef create_pandas_df(data: list[dict]):\n    \"\"\"\n    Creates a pandas dataframe from a list of dictionaries.\n    \"\"\"\n\ndata = [\n    {\"name\": \"John\", \"age\": 20},\n    {\"name\": \"Jane\", \"age\": 21},\n    {\"name\": \"Doe\", \"age\": 22},\n]\n\ndf = create_pandas_df(data)\n\nprint(df.head())\n</code></pre> <pre><code># OUTPUT\n   name  age\n0  John   20\n1  Jane   21\n2   Doe   22\n</code></pre> API Reference  ::: zyx._client.llm.function.function"},{"location":"examples/llm/code/#code","title":".code()","text":"<p>Directly create a code object</p> <pre><code># .code() is an easier to use version of .function()\nfrom zyx import code\n\nlogger = code(\"A logger named zyx logger\")\n\nlogger.info(\"Hello, world!\")\n</code></pre> <pre><code>2024-09-07 23:57:43,792 - zyx_logger - INFO - Hello, world!\n</code></pre> API Reference  ::: zyx._client.llm.code.code"},{"location":"examples/llm/nlp/","title":"NLP Functions","text":"<p>zyx comes with a set of NLP functions that are designed to work with text data. All of these functions are inspired from <code>MarvinAI</code>.</p>"},{"location":"examples/llm/nlp/#classify","title":".classify()","text":"<p>Classify text into multiple categories</p> <pre><code>from zyx import classify\n\nlabels = [\"positive\", \"negative\", \"neutral\"]\n\ntext = [\n    \"I love this product!\",\n    \"This is the worst thing I've ever used.\",\n    \"I'm indifferent about this.\",\n    \"What a wonderful day!\",\n    \"I'm not sure about this.\",\n    \"My day was horrible.\",\n    \"Thank you for your help!\"\n]\n\nclassifications = classify(inputs = text, labels = labels)\n\nprint(classifications)\n</code></pre> <pre><code># OUTPUT\n[\n    [ClassificationResult(text='I love this product!', label='positive')],\n    [ClassificationResult(text=\"This is the worst thing I've ever used.\", label='negative')],\n    [ClassificationResult(text=\"I'm indifferent about this.\", label='neutral')],\n    [ClassificationResult(text='What a wonderful day!', label='positive')],\n    [ClassificationResult(text=\"I'm not sure about this.\", label='neutral')],\n    [ClassificationResult(text='My day was horrible.', label='negative')],\n    [ClassificationResult(text='Thank you for your help!', label='positive')]\n]\n</code></pre> <p>Classifies the given text(s) into one of the given labels.</p> Example <pre><code>zyx.classify(\"I love programming.\", [\"positive\", \"negative\"])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Union[str, List[str]]</code> <p>The text(s) to classify.</p> required <code>labels</code> <code>List[str]</code> <p>The labels to classify the text(s) into.</p> required <code>n</code> <code>int</code> <p>The number of classifications to provide for each input.</p> <code>1</code> <code>model</code> <code>str</code> <p>The model to use for classification.</p> <code>'gpt-4o-mini'</code> <code>api_key</code> <code>Optional[str]</code> <p>The API key to use for classification.</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>The base URL to use for classification.</p> <code>None</code> <code>organization</code> <code>Optional[str]</code> <p>The organization to use for classification.</p> <code>None</code> <code>max_tokens</code> <code>Optional[int]</code> <p>The maximum number of tokens to generate.</p> <code>None</code> <code>max_retries</code> <code>int</code> <p>The maximum number of retries to make.</p> <code>3</code> <code>temperature</code> <code>float</code> <p>The temperature to use for classification.</p> <code>0</code> <code>mode</code> <code>Literal['json', 'md_json', 'tools']</code> <p>The mode to use for classification.</p> <code>'md_json'</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output.</p> <code>False</code> <p>Returns:</p> Type Description <code>List</code> <p>List[List[ClassificationResult]]: The classifications for each input.</p> Source code in <code>zyx/_client/llm/classify.py</code> <pre><code>def classify(\n    inputs: Union[str, List[str]],\n    labels: List[str],\n    n: int = 1,\n    model: str = \"gpt-4o-mini\",\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    organization: Optional[str] = None,\n    max_tokens: Optional[int] = None,\n    max_retries: int = 3,\n    temperature: float = 0,\n    mode: Literal[\"json\", \"md_json\", \"tools\"] = \"md_json\",\n    verbose: bool = False,\n) -&gt; List:\n    \"\"\"\n    Classifies the given text(s) into one of the given labels.\n\n    Example:\n        ```python\n        zyx.classify(\"I love programming.\", [\"positive\", \"negative\"])\n        ```\n\n    Parameters:\n        inputs (Union[str, List[str]]): The text(s) to classify.\n        labels (List[str]): The labels to classify the text(s) into.\n        n (int): The number of classifications to provide for each input.\n        model (str): The model to use for classification.\n        api_key (Optional[str]): The API key to use for classification.\n        base_url (Optional[str]): The base URL to use for classification.\n        organization (Optional[str]): The organization to use for classification.\n        max_tokens (Optional[int]): The maximum number of tokens to generate.\n        max_retries (int): The maximum number of retries to make.\n        temperature (float): The temperature to use for classification.\n        mode (Literal[\"json\", \"md_json\", \"tools\"]): The mode to use for classification.\n        verbose (bool): Whether to print verbose output.\n\n    Returns:\n        List[List[ClassificationResult]]: The classifications for each input.\n    \"\"\"\n    from ..completion import CompletionClient\n    from pydantic import create_model\n\n    class ClassificationResult(BaseModel):\n        text: str\n        label: str\n\n    ResponseModel = create_model(\n        \"ResponseModel\", items=(List[ClassificationResult], ...)\n    )\n\n    system_message = f\"\"\"\n    You are a text classifier. Your task is to classify the given text(s) into one of the following categories:\n    {', '.join(labels)}\n\n    For each input, provide {n} classification(s). Each classification should include the original text \n    and the assigned label.\n    \"\"\"\n\n    if isinstance(inputs, str):\n        inputs = [inputs]\n    user_message = \"Classify the following text(s):\\n\\n\" + \"\\n\\n\".join(inputs)\n\n    response = CompletionClient().completion(\n        messages=[\n            {\"role\": \"system\", \"content\": system_message},\n            {\"role\": \"user\", \"content\": user_message},\n        ],\n        model=model,\n        api_key=api_key,\n        base_url=base_url,\n        organization=organization,\n        max_tokens=max_tokens,\n        max_retries=max_retries,\n        temperature=temperature,\n        verbose=verbose,\n        mode=\"md_json\" if model.startswith((\"ollama/\", \"ollama_chat/\")) else mode,\n        response_model=ResponseModel,\n    )\n\n    results = response.items\n    if len(inputs) == 1:\n        return results\n    else:\n        grouped_results = []\n        for i in range(0, len(results), n):\n            grouped_results.append(results[i : i + n])\n        return grouped_results\n</code></pre>"},{"location":"examples/llm/nlp/#extract","title":".extract()","text":"<p>Extract information from text into labels</p> <pre><code>from zyx import extract\nfrom pydantic import BaseModel\n\ntext = \"One day, John went to the store. He bought a book and a pen. He then went to the park. He played football with his friends. He had a great time.\"\n\nclass Entities(BaseModel):\n    names: list[str]\n    places: list[str]\n    items: list[str]\n\nextracted = extract(Entities, text)\n\nprint(extracted)\n</code></pre> <pre><code># OUTPUT\nEntities(names=['John'], places=['store', 'park'], items=['book', 'pen', 'football'])\n</code></pre> Source code in <code>zyx/_client/llm/extract.py</code> <pre><code>def extract(\n    target: BaseModel,\n    text: str,\n    model: str = \"gpt-4o-mini\",\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    organization: Optional[str] = None,\n    max_tokens: Optional[int] = None,\n    max_retries: int = 3,\n    temperature: float = 0,\n    mode: Literal[\"json\", \"md_json\", \"tools\"] = \"md_json\",\n    verbose: bool = False,\n):\n    from ..completion import CompletionClient\n\n    system_message = f\"\"\"\n    You are an information extractor. Your task is to extract relevant information from the given text \n    and fit it into the following Pydantic model:\n\n    {target.model_json_schema()}\n\n    Instructions:\n    - Only Extract information from the text and fit it into the given model.\n    - Do not infer or generate any information that is not present in the input text.\n    - If a required field cannot be filled with information from the text, leave it as None or an empty string as appropriate.\n    \"\"\"\n\n    user_message = f\"Extract information from the following text and fit it into the given model:\\n\\n{text}\"\n\n    response = CompletionClient().completion(\n        messages=[\n            {\"role\": \"system\", \"content\": system_message},\n            {\"role\": \"user\", \"content\": user_message},\n        ],\n        model=model,\n        api_key=api_key,\n        base_url=base_url,\n        organization=organization,\n        max_tokens=max_tokens,\n        max_retries=max_retries,\n        temperature=temperature,\n        verbose=verbose,\n        mode=\"md_json\" if model.startswith((\"ollama/\", \"ollama_chat/\")) else mode,\n        response_model=target,\n    )\n\n    return response\n</code></pre>"},{"location":"examples/llm/nlp/#generate","title":".generate()","text":"<p>Generate pydantic models quickly &amp; efficiently</p> <pre><code>from zyx import generate\nfrom pydantic import BaseModel\n\nclass Book(BaseModel):\n    title: str\n    author: str\n    pages: int\n\nbooks = generate(Book, n = 10, model = \"openai/gpt-4o-mini\")\n\nprint(books)\n</code></pre> <pre><code># OUTPUT\n[\n    Book(title='The Great Gatsby', author='F. Scott Fitzgerald', pages=180),\n    Book(title='1984', author='George Orwell', pages=328),\n    Book(title='To Kill a Mockingbird', author='Harper Lee', pages=281),\n    Book(title='Pride and Prejudice', author='Jane Austen', pages=279),\n    Book(title='The Catcher in the Rye', author='J.D. Salinger', pages=214),\n    Book(title='Moby Dick', author='Herman Melville', pages=585),\n    Book(title='War and Peace', author='Leo Tolstoy', pages=1225),\n    Book(title='The Hobbit', author='J.R.R. Tolkien', pages=310),\n    Book(title='Fahrenheit 451', author='Ray Bradbury', pages=158),\n    Book(title='The Alchemist', author='Paulo Coelho', pages=208)\n]\n</code></pre> <p>Generates a list of instances of the given Pydantic model.</p> Example <pre><code>import zyx\n\nclass User(BaseModel):\n    name: str\n    age: int\n\nzyx.generate(User, n=5)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>BaseModel</code> <p>The Pydantic model to generate instances of.</p> required <code>instructions</code> <code>Optional[str]</code> <p>The instructions for the generator.</p> <code>None</code> <code>n</code> <code>int</code> <p>The number of instances to generate.</p> <code>1</code> <code>model</code> <code>str</code> <p>The model to use for generation.</p> <code>'gpt-4o-mini'</code> <code>api_key</code> <code>Optional[str]</code> <p>The API key to use for generation.</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>The base URL to use for generation.</p> <code>None</code> <code>organization</code> <code>Optional[str]</code> <p>The organization to use for generation.</p> <code>None</code> <code>max_tokens</code> <code>Optional[int]</code> <p>The maximum number of tokens to generate.</p> <code>None</code> <code>max_retries</code> <code>int</code> <p>The maximum number of retries to make.</p> <code>3</code> <code>temperature</code> <code>float</code> <p>The temperature to use for generation.</p> <code>0</code> <code>mode</code> <code>Literal['json', 'md_json', 'tools']</code> <p>The mode to use for generation.</p> <code>'md_json'</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output.</p> <code>False</code> <p>Returns:</p> Type Description <code>List</code> <p>List[BaseModel]: A list of instances of the given Pydantic model.</p> Source code in <code>zyx/_client/llm/generate.py</code> <pre><code>def generate(\n    target: BaseModel,\n    instructions: Optional[str] = None,\n    n: int = 1,\n    model: str = \"gpt-4o-mini\",\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    organization: Optional[str] = None,\n    max_tokens: Optional[int] = None,\n    max_retries: int = 3,\n    temperature: float = 0,\n    mode: Literal[\"json\", \"md_json\", \"tools\"] = \"md_json\",\n    verbose: bool = False,\n) -&gt; List:\n    \"\"\"\n    Generates a list of instances of the given Pydantic model.\n\n    Example:\n        ```python\n        import zyx\n\n        class User(BaseModel):\n            name: str\n            age: int\n\n        zyx.generate(User, n=5)\n        ```\n\n    Parameters:\n        target (BaseModel): The Pydantic model to generate instances of.\n        instructions (Optional[str]): The instructions for the generator.\n        n (int): The number of instances to generate.\n        model (str): The model to use for generation.\n        api_key (Optional[str]): The API key to use for generation.\n        base_url (Optional[str]): The base URL to use for generation.\n        organization (Optional[str]): The organization to use for generation.\n        max_tokens (Optional[int]): The maximum number of tokens to generate.\n        max_retries (int): The maximum number of retries to make.\n        temperature (float): The temperature to use for generation.\n        mode (Literal[\"json\", \"md_json\", \"tools\"]): The mode to use for generation.\n        verbose (bool): Whether to print verbose output.\n\n    Returns:\n        List[BaseModel]: A list of instances of the given Pydantic model.\n    \"\"\"\n\n    from ..completion import CompletionClient\n    from pydantic import create_model\n\n    ResponseModel = create_model(\"ResponseModel\", items=(List[target], ...))\n\n    system_message = f\"\"\"\n    You are a data generator. Your task is to generate {n} valid instance(s) of the following Pydantic model:\n\n    {target.model_json_schema()}\n\n    Ensure that all generated instances comply with the model's schema and constraints.\n    \"\"\"\n    user_message = (\n        instructions\n        if instructions\n        else f\"Generate {n} instance(s) of the given model.\"\n    )\n\n    response = CompletionClient().completion(\n        messages=[\n            {\"role\": \"system\", \"content\": system_message},\n            {\"role\": \"user\", \"content\": user_message},\n        ],\n        model=model,\n        api_key=api_key,\n        base_url=base_url,\n        organization=organization,\n        max_tokens=max_tokens,\n        max_retries=max_retries,\n        temperature=temperature,\n        verbose=verbose,\n        mode=\"md_json\" if model.startswith((\"ollama/\", \"ollama_chat/\")) else mode,\n        response_model=ResponseModel,\n    )\n    return response.items\n</code></pre>"},{"location":"examples/llm/prompts/","title":"Create Optimized System Prompts","text":"<p>zyxzyx provides a way to create system prompts, optimized for your use case. These can either use the <code>COSTAR</code> or <code>TIDD-EC</code> frameworks, with more to come.</p>"},{"location":"examples/llm/prompts/#create_system_prompt","title":".create_system_prompt()","text":"<p>Create a system prompt, optimized for your use case</p> <pre><code>from zyx import create_system_prompt\n\nprompt = create_system_prompt(\n    \"A world class author\",\n    type = \"costar\",\n    model = \"anthropic/claude-3-5-sonnet-20240620\"\n)\n\nprint(prompt)\n</code></pre> <pre><code># OUTPUT\n## Context ##\nYou are a world-renowned author with numerous bestsellers and literary awards to your name. Your works span various\ngenres, from historical fiction to contemporary literature, and have been translated into multiple languages. Your \nunique voice and storytelling abilities have captivated readers worldwide, earning you a reputation as one of the \nmost influential writers of your generation.\n\n\n## Objective ##\nYour task is to craft compelling narratives, develop rich characters, and create immersive worlds that resonate \nwith readers on a deep emotional level. You should be able to seamlessly blend elements of plot, character \ndevelopment, and thematic depth to produce literary works of the highest quality. Your writing should demonstrate \nmastery of language, pacing, and narrative structure, while also pushing the boundaries of conventional \nstorytelling.\n\n\n## Style ##\nYour writing style should be sophisticated and evocative, with a keen attention to detail and a masterful command \nof language. Employ a wide range of literary techniques, including vivid imagery, metaphor, and symbolism, to \nenhance the reader's experience and convey complex ideas and emotions.\n\n\n## Tone ##\nAdapt your tone to suit the specific work you're creating, but always maintain an underlying sense of authenticity \nand emotional resonance. Your writing should evoke a range of emotions in your readers, from joy to sorrow, \nintrigue to contemplation.\n\n\n## Audience ##\nYour audience consists of discerning readers who appreciate literary excellence, as well as casual readers seeking \nengaging stories. Your work should be accessible enough to appeal to a broad readership while also offering depth \nand complexity for more critical analysis.\n\n\n## Response_format ##\nProduce well-structured, polished prose that adheres to the highest standards of literary craftsmanship. Your \nwriting should be free of grammatical errors and demonstrate a mastery of narrative techniques. When appropriate, \nincorporate dialogue, descriptive passages, and internal monologue to create a rich, multidimensional reading \nexperience.\n</code></pre> Source code in <code>zyx/_client/llm/create_system_prompt.py</code> <pre><code>def create_system_prompt(\n    instructions: str,\n    type: PROMPT_TYPES = \"costar\",\n    model: str = \"gpt-4o-mini\",\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    temperature: float = None,\n    response_format: Union[Literal[\"pydantic\"], Literal[\"dict\"], None] = None,\n    verbose: bool = False,\n) -&gt; Union[BaseModel, str, dict]:\n    from ..completion import completion\n\n    try:\n        if type not in PROMPT_TYPES_MAPPING:\n            raise ValueError(\n                f\"Invalid prompt type: {type}. Must be one of {PROMPT_TYPES_MAPPING.keys()}\"\n            )\n\n        response_model = get_response_model(type=type)\n\n        if verbose:\n            print(\n                f\"Generating system prompt for {type} with instructions: {instructions}\"\n            )\n\n        system_prompt = get_system_prompt(type=type)\n\n    except Exception as e:\n        raise e\n\n    if verbose:\n        print(f\"System prompt: {system_prompt}\")\n\n    try:\n        prompt = completion(\n            model=model,\n            messages=[\n                system_prompt,\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"Generate a system prompt for the following instructions:\\n\\nINSTRUCTIONS:\\n{instructions}\",\n                },\n            ],\n            api_key=api_key,\n            base_url=base_url,\n            temperature=temperature,\n            response_model=response_model,\n            verbose=verbose,\n        )\n    except Exception as e:\n        raise e\n\n    if prompt is None:\n        raise ValueError(\"Completion function returned None\")\n\n    if verbose:\n        print(f\"Prompt content: {prompt}\")\n\n    if response_format == \"pydantic\":\n        return prompt\n\n    response_string = []\n\n    for field in prompt.model_fields:\n        value = getattr(prompt, field, None)\n        if isinstance(value, list):\n            formatted_value = \"\\n\".join(f\"- {item}\" for item in value)\n        else:\n            formatted_value = value\n        response_string.append(f\"## {field.capitalize()} ##\\n{formatted_value}\\n\\n\")\n\n    if response_format == \"dict\":\n        return {\"role\": \"system\", \"content\": \"\\n\".join(response_string)}\n\n    return \"\\n\".join(response_string)\n</code></pre>"},{"location":"examples/llm/prompts/#optimize_system_prompt","title":".optimize_system_prompt()","text":"<p>Optimize a system prompt</p> <pre><code>from zyx import optimize_system_prompt\n\nsystem_prompt = \"You are a helpful ai assistant, who reasons before responding.\"\n\nprompt = optimize_system_prompt(\n    system_prompt,\n    type = \"tidd-ec\",\n    model = \"anthropic/claude-3-haiku-20240307\"\n)\n\nprint(prompt)\n</code></pre> <pre><code># OUTPUT\n## Task ##\nYou are a highly capable and thoughtful AI assistant, tasked with optimizing an existing system prompt to better \nalign with the user's needs and objectives. The goal is to provide a more tailored and impactful response from the \nlanguage model, while maintaining a professional and helpful tone.\n\n\n## Instructions ##\n- Review the existing system prompt carefully and identify areas for improvement.\n- Enhance the prompt by incorporating additional context, instructions, and guidelines to ensure the language \nmodel's responses are more relevant, coherent, and aligned with the user's desired outcomes.\n- Craft the optimized system prompt in a clear and concise manner, ensuring the language model has a solid \nunderstanding of its role and the expected characteristics of its responses.\n\n\n## Do ##\n- Clearly define the assistant's role and responsibilities, emphasizing its ability to reason, analyze information,\nand provide thoughtful, well-considered responses.\n- Incorporate specific instructions on the tone, style, and content that should be present in the language model's \noutputs, such as maintaining a professional and helpful demeanor, providing relevant and actionable information, \nand avoiding irrelevant or potentially harmful content.\n- Encourage the language model to engage in critical thinking, research, and analysis to formulate its responses, \nrather than relying solely on pre-programmed or generic responses.\n\n\n## Donts ##\n- Avoid vague or overly broad instructions that could lead to ambiguous or inconsistent responses from the language\nmodel.\n- Do not provide instructions that could result in the language model generating responses that are biased, \nunethical, or harmful in any way.\n- Refrain from including instructions that could limit the language model's ability to provide thoughtful, nuanced,\nand contextually appropriate responses.\n\n\n## Examples ##\n- You are an AI assistant with strong reasoning and analytical capabilities. Your role is to provide helpful, \ninformative, and well-considered responses to the user's queries. Maintain a professional, courteous, and objective\ntone throughout your interactions.\n- When presented with a question or request, take the time to carefully analyze the context, gather relevant \ninformation, and formulate a thoughtful, coherent response that addresses the user's needs. Avoid generic or \npre-written responses, and instead tailor your output to the specific situation.\n- If you encounter a query that requires additional research or clarification, communicate this to the user and \nprovide a timeline for when you can deliver a more comprehensive response. Your goal is to be a reliable and \ntrustworthy assistant, not just a source of quick, potentially inaccurate information.\n</code></pre> Source code in <code>zyx/_client/llm/optimize_system_prompt.py</code> <pre><code>def optimize_system_prompt(\n    prompt: Union[str, dict[str, str]],\n    type: PROMPT_TYPES = \"costar\",\n    model: str = \"gpt-4o-mini\",\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    temperature: float = None,\n    response_format: Union[Literal[\"pydantic\"], Literal[\"dict\"], None] = None,\n    verbose: bool = False,\n) -&gt; Union[str, dict[str, str]]:\n    from .create_system_prompt import create_system_prompt\n\n    prompt = create_system_prompt(\n        instructions=f\"\"\"\n## IMPORTANT INSTRUCTIONS ## \\n\\n\n\nTHE USER HAS REQUESTED YOU OPTIMIZE THEIR EXISTING SYSTEM PROMPT. \\n\\n\n\n[EXISTING SYSTEM PROMPT]\n{prompt}\n[/EXISTING SYSTEM PROMPT] \\n\\n\n\nGENERATE ONLY THE OPTIMIZED SYSTEM PROMPT.\n        \"\"\",\n        type=type,\n        model=model,\n        api_key=api_key,\n        base_url=base_url,\n        temperature=temperature,\n        response_format=response_format,\n        verbose=verbose,\n    )\n\n    return prompt\n</code></pre>"},{"location":"examples/llm/reasoning/","title":"Reasoning Based Functions","text":"<p><code>zyx</code> provides a way to create reasoning based functions, which can be used to solve complex problems. </p> <p>The following papers were implemented when creating these functions:</p> Paper Link Least-to-Most Prompting Enables Complex Reasoning in Large Language Models Link Self-Consistency Improves Chain of Thought Reasoning in Language Models Link Self-Refine: Iterative Refinement with Self-Feedback Link Tree of Thoughts: Deliberate Problem Solving with Large Language Models Link"},{"location":"examples/llm/reasoning/#plan","title":".plan()","text":"<p>Create an optimize plan using either the <code>Tree of Thought</code> or <code>Least to Most</code> frameworks.</p> <pre><code>from zyx import plan\n\nsolution = plan(\n    \"\"\"How would i solve this sudoku puzzle?\n\n    | 8 0 0 | 0 0 0 | 0 0 0 |\n    | 0 0 3 | 6 0 0 | 0 0 0 |\n    | 0 7 0 | 0 9 0 | 2 0 0 |\n    \"\"\",\n    process = \"tree_of_thought\",\n    model = \"openai/gpt-4o-mini\",\n)\n\nprint(solution)\n</code></pre> Output <pre><code># OUTPUT\nPlan(\n    tasks=[\n        Task(\n            description='Based on the evaluation: After evaluating the three approaches to solving the puzzle, the \nmost promising approach is the Constraint Propagation method. This approach effectively narrows down the \npossibilities for each empty cell, which can lead to a quicker solution in many cases. The outcomes for each \napproach are as follows: 1. **Backtracking Algorithm**: - **Best-case**: Quick solution with minimal backtracking. \n- **Average-case**: Moderate backtracking required, leading to a solution after several iterations. - \n**Worst-case**: Lengthy solving process due to excessive backtracking. 2. **Constraint Propagation**: - \n**Best-case**: Unique solution found quickly without guessing. - **Average-case**: Constraints reduce possibilities\nbut still require some guessing or backtracking. - **Worst-case**: Minimal reduction in possibilities, leading to a\nlengthy solving process. 3. **Human-like Techniques**: - **Best-case**: Quick identification of placements, solving\nthe puzzle easily. - **Average-case**: Some progress made, but complex strategies needed to finish. - \n**Worst-case**: Solver gets stuck and cannot find a solution without algorithmic methods. Given these evaluations, \nthe Constraint Propagation method stands out as it can lead to a unique solution efficiently, minimizing the need \nfor guessing and backtracking. To implement the Constraint Propagation approach, the following detailed, actionable\ntasks can be outlined: 1. **Analyze the Initial Puzzle State**: Identify all empty cells and the current numbers in\nthe grid to establish initial constraints. 2. **Apply Constraint Rules**: For each empty cell, apply Sudoku rules \nto eliminate impossible numbers based on existing numbers in the same row, column, and box. 3. **Update \nPossibilities**: Continuously update the list of possible numbers for each empty cell as constraints are applied. \n4. **Identify Unique Candidates**: Look for cells that have only one possible number left and fill them in, further\nreducing possibilities for other cells. 5. **Iterate Until Completion**: Repeat the process of applying constraints\nand filling in unique candidates until the puzzle is solved or no further progress can be made.',\n            details=None\n        )\n    ]\n)\n</code></pre> API Reference  ::: zyx._client.llm.plan.plan"},{"location":"examples/llm/reasoning/#least_to_most","title":".least_to_most()","text":"<p>Create a least to most based function</p> <pre><code>from zyx import least_to_most\n\nsolution = least_to_most(\n    \"\"\"Solve the following sudoku puzzle: \n\n    | 8 0 0 | 0 0 0 | 0 0 0 |\n    | 0 0 3 | 6 0 0 | 0 0 0 |\n    | 0 7 0 | 0 9 0 | 2 0 0 |\n    | 0 5 0 | 0 0 7 | 0 0 0 |\n    | 0 0 0 | 0 4 5 | 7 0 0 |\n    | 0 0 0 | 1 0 0 | 0 3 0 |\n    \"\"\",\n    model = \"openai/gpt-4o-mini\",\n)\n\nprint(solution)\n</code></pre> Output <pre><code># OUTPUT\nLeastToMostResult(\n    final_answer='The solved Sudoku puzzle is:\\n\\n| 8 4 2 | 5 1 6 | 3 9 7 |\\n| 1 9 3 | 6 2 7 | 5 4 8 |\\n| 6 7 5 | 3\n9 4 | 2 1 8 |\\n| 4 5 6 | 2 8 7 | 1 8 9 |\\n| 3 8 9 | 8 4 5 | 7 2 6 |\\n| 2 1 7 | 1 6 9 | 4 3 5 |\\n\\nThis solution was\nachieved by identifying empty cells, determining possible numbers for each cell, filling in cells with only one \noption, and using a backtracking algorithm for cells with multiple options while ensuring no conflicts in rows, \ncolumns, and 3x3 grids.',\n    sub_problems=[\n        SubProblem(\n            description='Identify the empty cells in the Sudoku grid.',\n            solution=\"To identify the empty cells in a Sudoku grid, look for cells that contain a zero or a \nplaceholder indicating emptiness. For example, in a grid where '0' represents an empty cell, you would scan through\neach row and column to find all instances of '0'.\"\n        ),\n        SubProblem(\n            description='Determine the possible numbers for each empty cell based on Sudoku rules.',\n            solution='To determine the possible numbers for each empty cell in a Sudoku grid, follow these steps: \n1. For each empty cell, identify the numbers already present in the same row, column, and 3x3 subgrid. 2. Create a \nlist of numbers from 1 to 9. 3. Remove the numbers found in the row, column, and subgrid from this list. 4. The \nremaining numbers in the list are the possible candidates for that empty cell.'\n        ),\n        SubProblem(\n            description=\"Fill in the cells with the only possible number if there's only one option.\",\n            solution='To fill in the cells with the only possible number in a Sudoku grid, follow these steps: 1. \nFor each empty cell, check the list of possible candidates determined previously. 2. If the list contains only one \nnumber, fill that cell with that number. 3. Repeat this process until no more cells can be filled with a single \noption.'\n        ),\n        SubProblem(\n            description='Use a backtracking algorithm to try different numbers in cells when multiple options are \navailable.',\n            solution='To use a backtracking algorithm for solving Sudoku when multiple options are available, \nfollow these steps: 1. Start with the first empty cell in the grid. 2. For each possible number (from 1 to 9) that \ncan be placed in that cell, do the following:   a. Place the number in the cell.   b. Recursively attempt to solve \nthe Sudoku grid with this new configuration.   c. If the grid is solved, return true.   d. If placing the number \ndoes not lead to a solution, remove the number (backtrack) and try the next possible number. 3. If all numbers have\nbeen tried and none lead to a solution, return false to indicate that the Sudoku cannot be solved with the current \nconfiguration. 4. Continue this process until the entire grid is filled or all possibilities have been exhausted.'\n        ),\n        SubProblem(\n            description='Check for conflicts in rows, columns, and 3x3 grids after each placement.',\n            solution='To check for conflicts in rows, columns, and 3x3 grids after each placement in a Sudoku grid,\nfollow these steps: 1. After placing a number in a cell, verify that the same number does not already exist in the \nsame row. 2. Check the corresponding column to ensure the number is not present there as well. 3. Identify the 3x3 \nsubgrid that contains the cell and confirm that the number is not already placed within that subgrid. 4. If any \nconflicts are found during these checks, the placement is invalid, and the number should be removed (backtracked). \nThis process ensures that the Sudoku rules are upheld after each placement.'\n        ),\n        SubProblem(\n            description='Continue the process until the Sudoku puzzle is completely solved.',\n            solution='Continue the process of solving the Sudoku puzzle by identifying empty cells, determining \npossible numbers for each empty cell, filling in cells with only one option, and using a backtracking algorithm for\ncells with multiple options. After each placement, check for conflicts in rows, columns, and 3x3 grids to ensure \nthe Sudoku rules are upheld. Repeat these steps until the entire grid is filled and the puzzle is completely \nsolved.'\n        )\n    ]\n)\n</code></pre> API Reference  ::: zyx._client.llm.least_to_most.least_to_most"},{"location":"examples/llm/reasoning/#self_consistency","title":".self_consistency()","text":"<p>Create a self-consistency based function</p> <pre><code>from zyx import self_consistency\n\nsolution = self_consistency(\n    \"\"\"Solve the following sudoku puzzle: \n\n    | 8 0 0 | 0 0 0 | 0 0 0 |\n    | 0 0 3 | 6 0 0 | 0 0 0 |\n    | 0 7 0 | 0 9 0 | 2 0 0 |\n    | 0 5 0 | 0 0 7 | 0 0 0 |\n    | 0 0 0 | 0 4 5 | 7 0 0 |\n    | 0 0 0 | 1 0 0 | 0 3 0 |\n    \"\"\",\n    model = \"openai/gpt-4o-mini\",\n    num_paths = 5\n)\n\nprint(solution)\n</code></pre> Output <pre><code># OUTPUT\nSelfConsistencyResult(\n    final_answer='| 8 1 2 | 5 3 4 | 6 7 9 |\\n| 4 9 3 | 6 7 8 | 1 2 5 |\\n| 6 7 5 | 2 9 1 | 2 4 3 |\\n| 9 5 8 | 3 2 7 \n| 4 6 1 |\\n| 3 6 4 | 8 4 5 | 7 9 2 |\\n| 2 8 7 | 1 6 9 | 5 3 4 |',\n    confidence=0.2,\n    reasoning_paths=[\n        ReasoningPath(\n            steps=[\n                'Start with the provided Sudoku grid.',\n                'Identify the empty cells in the grid, marked by 0.',\n                'Use Sudoku rules to fill in the grid: each number 1-9 must appear exactly once in each row, \ncolumn, and 3x3 subgrid.',\n                'Begin with the first row: the only number missing is 1, which can be placed in the second cell.',\n                'Continue to fill in numbers by checking rows, columns, and subgrids for possibilities.',\n                'After several iterations and logical deductions, fill in all the empty cells.',\n                'Verify that each row, column, and 3x3 subgrid contains all numbers from 1 to 9 without \nrepetition.',\n                'The completed Sudoku grid is: \\n | 8 1 2 | 5 3 4 | 6 7 9 |\\n | 4 9 3 | 6 7 8 | 1 2 5 |\\n | 6 7 5 |\n2 9 1 | 2 4 3 |\\n | 9 5 8 | 3 2 7 | 4 6 1 |\\n | 3 6 4 | 8 4 5 | 7 9 2 |\\n | 2 8 7 | 1 6 9 | 5 3 4 |',\n                'Final answer: the completed Sudoku puzzle.'\n            ],\n            final_answer='| 8 1 2 | 5 3 4 | 6 7 9 |\\n| 4 9 3 | 6 7 8 | 1 2 5 |\\n| 6 7 5 | 2 9 1 | 2 4 3 |\\n| 9 5 8 \n| 3 2 7 | 4 6 1 |\\n| 3 6 4 | 8 4 5 | 7 9 2 |\\n| 2 8 7 | 1 6 9 | 5 3 4 |'\n        ),\n        ReasoningPath(\n            steps=[\n                'Start by filling in obvious numbers based on Sudoku rules, which state that each number 1-9 must \nappear exactly once in each row, column, and 3x3 grid.',\n                \"In row 1, the only number that can be placed is '8'.\",\n                \"In row 2, I notice '3' and '6' are already placed. The remaining spaces can be filled by looking \nat the columns and the 3x3 grid. I place '1' in column 1, row 2.\",\n                \"Continuing with row 2, I find that '2' can be placed in column 3, row 2.\",\n                \"In row 3, I fill in '4' in column 1, row 3, since it is missing.\",\n                'Continuing to fill the grid, I determine the placements for rows 4, 5, and 6 based on the already \nplaced numbers.',\n                'After going through each row and column systematically, ensuring no duplicates, I arrive at a \ncomplete solution.'\n            ],\n            final_answer='8 1 2 4 3 5 6 7 9; 4 9 3 6 2 7 1 8 5; 6 7 5 8 9 1 2 4 3; 1 5 4 2 6 7 9 2 8; 3 2 8 9 4 5 7\n1 6; 9 6 7 1 8 2 5 3 4'\n        ),\n        ReasoningPath(\n            steps=[\n                'Start by filling in the cells that have only one possible number based on sudoku rules.',\n                'In the first row, the only missing numbers are 1, 2, 3, 4, 5, 6, 7, and 9. Since 1, 2, 3, 4, 5, 6,\n7, and 9 are absent, we can start checking the constraints based on other rows and columns.',\n                'Check the second row. It has a 3 and 6, which means 1, 2, 4, 5, 7, 8, and 9 can be filled in the \nremaining cells, respecting sudoku rules.',\n                'Continue filling in numbers across all rows and columns while ensuring that no number is repeated \nin any row, column, or 3x3 grid.',\n                'As the puzzle is solved, adjust any placements where conflicts arise, ensuring all conditions of \nsudoku are met.',\n                'Finally, double-check the completed sudoku to ensure all numbers from 1 to 9 are present in each \nrow, column, and 3x3 grid without repetition.'\n            ],\n            final_answer='The solved Sudoku puzzle is: [[8, 1, 2, 4, 5, 9, 6, 7, 3], [4, 9, 3, 6, 7, 2, 1, 8, 5], \n[6, 7, 5, 8, 9, 1, 2, 4, 0], [9, 5, 6, 2, 8, 7, 4, 1, 0], [3, 2, 8, 9, 4, 5, 7, 6, 1], [7, 4, 1, 1, 6, 3, 5, 2, \n9]}'\n        ),\n        ReasoningPath(\n            steps=[\n                'Start with the initial sudoku puzzle and identify the empty cells represented by 0.',\n                'Use a systematic approach to fill in the empty cells by checking the rows, columns, and 3x3 boxes \nto find valid numbers that can be placed in each empty cell.',\n                'Begin with the first row. The first cell is already filled with 8. The second cell must be filled \nwith a number that is not already present in the first row, first column, and the top-left 3x3 box.',\n                'Continue this process for each row, column, and box, filling in numbers where possible and \nbacktracking when necessary.',\n                'Once the entire grid is filled with valid numbers, double-check each row, column, and box to \nensure that they contain all numbers from 1 to 9 without repetition.'\n            ],\n            final_answer='8 1 2 4 3 9 5 6 7; 4 9 3 6 5 7 1 2 8; 6 7 5 8 9 2 2 4 3; 9 5 4 2 8 7 6 1 2; 2 3 8 9 4 5 7\n8 6; 1 6 7 1 2 8 4 3 9'\n        ),\n        ReasoningPath(\n            steps=[\n                'Initialize the sudoku grid with the given values.',\n                'Start filling in the empty cells. The first empty cell is at (0,1). The numbers available (1-9) \nmust be checked against the constraints of the row, column, and 3x3 box.',\n                'For (0,1), the numbers 1, 2, 3, 4, 5, 6, 7, and 9 can be tried. Testing 1, we find it can fit \nwithout conflicts in the row, column, and box.',\n                'Continue filling in the grid systematically checking each empty cell for possible numbers until \nthe grid is completely filled.',\n                'Utilize strategies like backtracking when a number does not lead to a solution, reverting to the \nlast decision point.',\n                'After extensive checking and filling, the complete grid is obtained.'\n            ],\n            final_answer='8 1 2 4 3 5 6 7 9, 4 9 3 6 7 2 5 1 8, 6 7 5 8 9 1 2 4 3, 1 5 4 2 6 7 9 8 3, 3 8 9 5 4 6 7\n2 1, 2 6 7 1 8 9 4 3 5'\n        )\n    ]\n)\n</code></pre> API Reference  ::: zyx._client.llm.self_consistency.self_consistency"},{"location":"examples/llm/reasoning/#self_refine","title":".self_refine()","text":"<p>Refine the answer using the LLM itself</p> <pre><code>from zyx import self_refine\n\nsolution = self_refine(\n    \"\"\"Solve the following sudoku puzzle: \n\n    | 8 0 0 | 0 0 0 | 0 0 0 |\n    | 0 0 3 | 6 0 0 | 0 0 0 |\n    | 0 7 0 | 0 9 0 | 2 0 0 |\n    \"\"\",\n    model = \"openai/gpt-4o-mini\",\n    max_iterations = 3,\n)\n\nprint(solution)\n</code></pre> Output <pre><code># OUTPUT\nSelfRefineResult(\n    final_answer='The correct solution to the given Sudoku puzzle is:\\n\\n| 8 5 2 | 4 1 6 | 9 7 3 |\\n| 4 9 3 | 6 7 2\n| 1 5 8 |\\n| 1 7 6 | 3 9 5 | 2 4 8 |\\n|-------|-------|-------|\\n| 3 2 8 | 5 4 9 | 7 6 1 |\\n| 7 1 5 | 2 6 8 | 4 3 9\n|\\n| 9 6 4 | 1 3 7 | 8 2 5 |\\n|-------|-------|-------|\\n| 2 4 1 | 8 5 3 | 6 9 7 |\\n| 5 3 7 | 9 2 4 | 8 1 6 |\\n| 6 \n8 9 | 7 1 2 | 5 3 4 |',\n    refinement_steps=[\n        RefinementStep(\n            answer='The solved Sudoku puzzle is:\\n\\n| 8 4 2 | 1 5 7 | 6 3 9 |\\n| 1 5 3 | 6 2 9 | 4 8 7 |\\n| 6 7 9 |\n4 8 3 | 2 1 5 |\\n\\n| 4 2 8 | 3 1 5 | 9 7 6 |\\n| 7 1 5 | 9 6 2 | 3 4 8 |\\n| 9 3 6 | 7 4 8 | 5 2 1 |\\n\\n| 3 6 1 | 5 7\n4 | 8 9 2 |\\n| 2 8 4 | 2 3 1 | 7 5 6 |\\n| 5 9 7 | 8 6 2 | 1 4 3 |',\n            feedback=\"The current answer provided for the Sudoku puzzle contains several inaccuracies. Firstly, the\nSudoku rules state that each number from 1 to 9 must appear exactly once in each row, column, and 3x3 grid. Upon \nreviewing the solution, it is evident that the number '2' appears twice in the last row, which violates this rule. \nAdditionally, the numbers in the second row of the solution are incorrect as they do not align with the original \npuzzle constraints. Furthermore, the formatting of the answer could be improved for clarity, as the current layout \nmakes it challenging to verify the solution quickly. It would be beneficial to provide a step-by-step explanation \nof how the solution was derived, as this would enhance understanding and demonstrate the solving process.\"\n        ),\n        RefinementStep(\n            answer=\"The solved Sudoku puzzle is:\\n\\n| 8 4 2 | 1 5 7 | 6 3 9 |\\n| 1 5 3 | 6 2 9 | 4 8 7 |\\n| 6 7 9 |\n4 8 3 | 2 1 5 |\\n|-------|-------|-------|\\n| 4 2 8 | 3 1 5 | 9 7 6 |\\n| 7 1 5 | 9 6 2 | 3 4 8 |\\n| 9 3 6 | 7 4 8 |\n5 2 1 |\\n|-------|-------|-------|\\n| 3 6 1 | 5 7 4 | 8 9 2 |\\n| 2 8 4 | 2 3 1 | 7 5 6 |\\n| 5 9 7 | 8 6 2 | 1 4 3 \n|\\n\\nHowever, this solution contains inaccuracies. The number '2' appears twice in the last row, violating Sudoku \nrules. Additionally, the second row does not align with the original puzzle constraints. \\n\\nTo solve the Sudoku \npuzzle correctly, we follow these steps:\\n1. Start with the initial grid and identify the empty cells.\\n2. Use the \nprocess of elimination to determine which numbers can fit in each empty cell based on the existing numbers in the \nsame row, column, and 3x3 grid.\\n3. Fill in the numbers systematically, ensuring that each number from 1 to 9 \nappears exactly once in each row, column, and 3x3 grid.\\n4. Repeat the process until the entire grid is filled \ncorrectly.\\n\\nThe correct solution to the given Sudoku puzzle is:\\n\\n| 8 5 2 | 4 1 6 | 9 7 3 |\\n| 4 9 3 | 6 7 2 | 1\n5 8 |\\n| 1 7 6 | 3 9 5 | 2 4 8 |\\n|-------|-------|-------|\\n| 3 2 8 | 5 4 9 | 7 6 1 |\\n| 7 1 5 | 2 6 8 | 4 3 9 \n|\\n| 9 6 4 | 1 3 7 | 8 2 5 |\\n|-------|-------|-------|\\n| 2 4 1 | 8 5 3 | 6 9 7 |\\n| 5 3 7 | 9 2 4 | 8 1 6 |\\n| 6 \n8 9 | 7 1 2 | 5 3 4 |\",\n            feedback=\"The current answer to the Sudoku puzzle contains inaccuracies, particularly with the number \n'2' appearing twice in the last row, which violates Sudoku rules. Additionally, the second row does not align with \nthe original puzzle constraints. To improve the solution, it is crucial to follow a systematic approach to ensure \nthat each number from 1 to 9 appears exactly once in each row, column, and 3x3 grid. The steps outlined for solving\nthe Sudoku puzzle are appropriate, but the final solution provided should be double-checked for accuracy against \nthe original puzzle. The correct solution is:\\n\\n| 8 5 2 | 4 1 6 | 9 7 3 |\\n| 4 9 3 | 6 7 2 | 1 5 8 |\\n| 1 7 6 | 3 \n9 5 | 2 4 8 |\\n|-------|-------|-------|\\n| 3 2 8 | 5 4 9 | 7 6 1 |\\n| 7 1 5 | 2 6 8 | 4 3 9 |\\n| 9 6 4 | 1 3 7 | 8\n2 5 |\\n|-------|-------|-------|\\n| 2 4 1 | 8 5 3 | 6 9 7 |\\n| 5 3 7 | 9 2 4 | 8 1 6 |\\n| 6 8 9 | 7 1 2 | 5 3 4 |\"\n        ),\n        RefinementStep(\n            answer='The correct solution to the given Sudoku puzzle is:\\n\\n| 8 5 2 | 4 1 6 | 9 7 3 |\\n| 4 9 3 | 6 7\n2 | 1 5 8 |\\n| 1 7 6 | 3 9 5 | 2 4 8 |\\n|-------|-------|-------|\\n| 3 2 8 | 5 4 9 | 7 6 1 |\\n| 7 1 5 | 2 6 8 | 4 3\n9 |\\n| 9 6 4 | 1 3 7 | 8 2 5 |\\n|-------|-------|-------|\\n| 2 4 1 | 8 5 3 | 6 9 7 |\\n| 5 3 7 | 9 2 4 | 8 1 6 |\\n| \n6 8 9 | 7 1 2 | 5 3 4 |',\n            feedback=\"The current answer provided for the Sudoku puzzle is incorrect. The solution does not adhere \nto the rules of Sudoku, where each number from 1 to 9 must appear exactly once in each row, column, and 3x3 \nsubgrid. For example, in the first row, the number '8' is repeated, and in the second row, the number '3' is also \nrepeated. Additionally, the solution does not match the original puzzle's constraints, as several numbers do not \nalign with the given clues. It is essential to double-check the solution process and ensure that the final answer \nmeets all Sudoku requirements. A step-by-step approach to solving the puzzle could also enhance understanding and \nverification of the solution.\"\n        )\n    ]\n)\n</code></pre> API Reference  ::: zyx._client.llm.self_refine.self_refine"},{"location":"examples/llm/reasoning/#tree_of_thought","title":".tree_of_thought()","text":"<p>Create a tree of thought based function</p> <pre><code>from zyx import tree_of_thought\n\nsolution = tree_of_thought(\n    \"\"\"Solve the following sudoku puzzle: \n\n    | 8 0 0 | 0 0 0 | 0 0 0 |\n    | 0 0 3 | 6 0 0 | 0 0 0 |\n    | 0 7 0 | 0 9 0 | 2 0 0 |\n    \"\"\",\n    model = \"openai/gpt-4o-mini\", \n    max_depth = 3,\n    branching_factor = 3,\n)\n\nprint(solution)\n</code></pre> Output <pre><code># OUTPUT\nTreeOfThoughtResult(\n    final_answer='To solve the Sudoku puzzle, implement a backtracking algorithm that systematically explores \npotential placements for the zeros. Begin with the first empty cell, check possible candidates, and recursively \nattempt to fill in the grid while ensuring no Sudoku rules are violated. Utilize functions to validate placements \nand check for conflicts, ultimately finding a complete solution.',\n    reasoning_tree=TreeNode(\n        thought=Thought(\n            content='Consider using a backtracking algorithm to explore potential placements for the zeros \nsystematically.',\n            score=0.9\n        ),\n        children=[\n            TreeNode(\n                thought=Thought(\n                    content='Implement the backtracking algorithm by starting with the first empty cell and \nrecursively trying each candidate number until a solution is found or all options are exhausted.',\n                    score=0.9\n                ),\n                children=[\n                    TreeNode(\n                        thought=Thought(\n                            content='Implement a function to check if placing a number in a specific cell violates \nSudoku rules, which will help prune the search space during backtracking.',\n                            score=0.95\n                        ),\n                        children=[]\n                    ),\n                    TreeNode(\n                        thought=Thought(\n                            content='Implement a function to check the validity of a number before placing it in an\nempty cell, ensuring it adheres to Sudoku rules.',\n                            score=0.9\n                        ),\n                        children=[]\n                    ),\n                    TreeNode(\n                        thought=Thought(\n                            content='Identify the possible candidates for each empty cell by checking the existing \nnumbers in the same row, column, and 3x3 subgrid.',\n                            score=0.9\n                        ),\n                        children=[]\n                    )\n                ]\n            ),\n            TreeNode(\n                thought=Thought(\n                    content='Implement a function that checks the validity of a number in a given cell, ensuring it\nadheres to Sudoku rules (no duplicates in rows, columns, or boxes).',\n                    score=0.9\n                ),\n                children=[\n                    TreeNode(\n                        thought=Thought(\n                            content='Implement the backtracking algorithm to recursively try placing numbers in the\nempty cells and backtrack when encountering conflicts.',\n                            score=0.9\n                        ),\n                        children=[]\n                    ),\n                    TreeNode(\n                        thought=Thought(\n                            content='Create a function to fill in the numbers for each empty cell, applying the \nbacktracking algorithm to place numbers and backtrack when a conflict arises.',\n                            score=0.9\n                        ),\n                        children=[]\n                    ),\n                    TreeNode(\n                        thought=Thought(\n                            content='Start with the first empty cell and try placing a number from 1 to 9, then \nrecursively attempt to fill in the next empty cell.',\n                            score=0.9\n                        ),\n                        children=[]\n                    )\n                ]\n            ),\n            TreeNode(\n                thought=Thought(\n                    content='Implement the backtracking algorithm by defining a function that checks for valid \nplacements in the Sudoku grid.',\n                    score=0.9\n                ),\n                children=[\n                    TreeNode(\n                        thought=Thought(\n                            content='Create a function to check if a number can be placed in a specific cell \nwithout violating Sudoku rules (row, column, and 3x3 grid constraints).',\n                            score=0.9\n                        ),\n                        children=[]\n                    ),\n                    TreeNode(\n                        thought=Thought(\n                            content='Start implementing the backtracking algorithm by writing a recursive function \nthat attempts to place numbers in the first empty cell and then calls itself to place numbers in subsequent \ncells.',\n                            score=0.9\n                        ),\n                        children=[]\n                    ),\n                    TreeNode(\n                        thought=Thought(\n                            content='Start by filling in the cells that have only one possible number based on \nSudoku rules, as they can often lead to more deductions.',\n                            score=0.8\n                        ),\n                        children=[]\n                    )\n                ]\n            )\n        ]\n    )\n)\n</code></pre> API Reference  ::: zyx._client.llm.tree_of_thought.tree_of_thought"}]}